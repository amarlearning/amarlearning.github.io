<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://amarpandey.me/favicon/favicon.png" />
<title>Docker - the right way | Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ</title>
<meta name="title" content="Docker - the right way" />
<meta name="description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles." />
<meta name="keywords" content="docker,best-practices,infrastructure,iac,devops,containers,security," />


<meta property="og:url" content="https://amarpandey.me/blog/docker---the-right-way/">
  <meta property="og:site_name" content="Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ">
  <meta property="og:title" content="Docker - the right way">
  <meta property="og:description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2022-01-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-01-23T00:00:00+00:00">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="Best-Practices">
    <meta property="article:tag" content="Infrastructure">
    <meta property="article:tag" content="Iac">
    <meta property="article:tag" content="Devops">
    <meta property="article:tag" content="Containers">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Docker - the right way">
  <meta name="twitter:description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">




  <meta itemprop="name" content="Docker - the right way">
  <meta itemprop="description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">
  <meta itemprop="datePublished" content="2022-01-23T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-01-23T00:00:00+00:00">
  <meta itemprop="wordCount" content="1769">
  <meta itemprop="keywords" content="Docker,Best-Practices,Infrastructure,Iac,Devops,Containers,Security">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header>


  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CN34V0ZGSQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-CN34V0ZGSQ');
  </script>


<a href="/" class="title">
  <h2>Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ</h2>
</a>
<nav><a href="/">Home</a>

<a href="/about/">About</a>

<a href="/projects/">Projects</a>


<a href="/blog">Blog</a>

</nav>

</header>
  <main>

<h1>Docker - the right way</h1>
<p>
  <i>
    <time datetime='2022-01-23' pubdate>
      23 Jan, 2022
    </time>
  </i>
</p>

<content>
  <p><img src="/images/docker-the-right-way/banner.png" alt="banner"></p>
<p>Docker is a software framework for building, running, and managing containers on servers and the cloud. Here are the several best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.</p>
<hr>
<h3 id="1-use-official-docker-image-as-base-image">1. Use Official Docker Image as Base Image</h3>
<p>Always use the official or verified base image when writing the docker file. Let&rsquo;s say you are developing a java application and want to build it and run it as a docker image. Instead of taking a base operating system image and installing java, maven, and other tools you need for your application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM ubuntu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN apt-get update <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get install -y openjdk-8-jdk <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get install -y ant <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get clean;
</span></span></code></pre></div><hr>
<p>Use the official Java image for your application. This will not only make your docker file cleaner but also let you use an official and verified image which is already built using the best practices.</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">FROM openjdk
</code></pre><hr>
<h3 id="2-use-specific-image-version">2. Use specific Image Version</h3>
<p>As you see from the previous script we have chosen <code>OpenJDK</code> as our base image, but now when we build our application image from the above docker file, it will always use the <strong>latest</strong> tag of the <code>OpenJDK</code> image.</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile"># Is same as FROM openjdk:latest
FROM openjdk
</code></pre><hr>
<p>The problem here is that we might get a different image version as in the previous build and the new image version may break stuff or cause unexpected behavior, so the <strong>latest</strong> tag is unpredictable, we don&rsquo;t know exactly which image we are getting. So instead of the random latest image tag, we need to fixate the version. <strong>We should be as specific as possible with the image version.</strong></p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">FROM openjdk:11-alpine
</code></pre><hr>
<h3 id="3-use-small-sized-official-image">3. Use small sized Official Image</h3>
<p>There are multiple official images of <code>openjdk</code> not only with different version numbers but also with the different operating system distribution, so the question here is <strong>which one to choose?</strong> and <strong>does it even matter?</strong></p>
<p>If the image is based on a <strong>full-blown operating system distribution</strong> like ubuntu or centos which has a bunch of tools already packaged in, which makes the <strong>image size large</strong>. But most of the time, we don&rsquo;t need these tools in our application image.</p>
<p>In contrast, having smaller images means, we need less storage space in the image repository as well as on a deployment server and of course, we can transfer the images faster when pulling or pushing them from the repository.</p>
<p>In addition to the size, there is another issue with images on a full-blown operating system with lots of tools installed and that is a <strong>security issue</strong> because such a base usually contains hundreds of known vulnerabilities and basically creates a larger attack surface to your application image.</p>
<p>In comparison, using smaller images with leaner operating system distribution which bundle the necessary system tools and libraries, we are minimizing the attack surface and building more secure images.</p>
<hr>
<h3 id="4-minimize-the-number-of-layers">4. Minimize the Number of Layers</h3>
<p>Every line in our <code>Dockerfile</code> will be treated as an image layer. Each layer increases the size of images since they are cached. Therefore, as the number of layers increases, the size also increases. It&rsquo;s always a good idea to combine <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> commands as much as possible since they create layers.</p>
<p>You can test this out with the <code>docker history</code> command:</p>
<pre tabindex="0"><code class="language-shell:title=Console" data-lang="shell:title=Console">$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
dockerfile   latest    194f98552a02   37 seconds ago   218MB

$ docker history 194f98552a02

IMAGE            CREATED BY                                       SIZE
194f98552a02     COPY . . # buildkit                              6.71kB
&lt;missing&gt;        RUN /bin/sh -c pip install -r requirem..         35.5MB
&lt;missing&gt;        COPY requirements.txt . # buildkit               58B
&lt;missing&gt;        WORKDIR /app
</code></pre><hr>
<p>If we see the above logs carefully, we can notice only the <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> command adds size to the image. we can reduce the image size by combining commands wherever possible. For example:</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">RUN apt-get update
RUN apt-get install -y openjdk-8-jdk
</code></pre><hr>
<p>Can be combined into a single <code>RUN</code> command:</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">RUN apt-get update &amp;&amp; apt-get install -y openjdk-8-jdk
</code></pre><hr>
<p>Thus, creating a single layer instead of multiple, which reduces the size of the final image.</p>
<hr>
<h3 id="5-optimize-caching-image-layers">5. Optimize Caching Image Layers</h3>
<p>Docker images are built based on Dockerfile. In Dockerfile, each line generates its layer during the building process. The layers are also cached and reused between different building processes if no changes are detected.</p>
<p>Let&rsquo;s take a look at the dockerfile based on a node alpine image:</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">FROM node:17.0.1-alpine

WORKDIR /app

COPY project /app

RUN npm install --production

CMD [&#34;node&#34;, &#34;src/index.js&#34;]
</code></pre><hr>
<p>As we discussed before each line creates its cached layer. Let&rsquo;s build this docker image and see what is happening.</p>
<pre tabindex="0"><code class="language-shell:title=Console" data-lang="shell:title=Console">Step 1/5 : FROM node:17.0.1-alpine
17.0.1-alpine: Pulling from library/node
Digest: sha256:959c4fc79a753b8b797c4fc9da967c7a81b4a3a3ff93d484dfe00092bf9fd584
Status: Downloaded newer image for node:17.0.1-alpine
 ---&gt; c0fc1c9c473b
Step 2/5 : WORKDIR /app
 ---&gt; Using cache
 ---&gt; f665e3b63c98
Step 3/5 : COPY project /app
 ---&gt; 8d4971fa2f3b
Step 4/5 : RUN npm install --production
 ---&gt; Running in a5eac87912ce

up to date, audited 1 package in 371ms

found 0 vulnerabilities
Removing intermediate container a5eac87912ce
 ---&gt; 9c21576cad06
Step 5/5 : CMD [&#34;node&#34;, &#34;src/index.js&#34;]
 ---&gt; Running in 1ff9c5bb72e7
Removing intermediate container 1ff9c5bb72e7
 ---&gt; 9783eef2c1d3
Successfully built 9783eef2c1d3
Successfully tagged dockerfile:latest
</code></pre><hr>
<p>Docker image from docker file was built completely from scratch, so it took 1 minute to build. Let&rsquo;s try to build again and see.</p>
<pre tabindex="0"><code class="language-shell:title=Console" data-lang="shell:title=Console">Step 1/5 : FROM node:17.0.1-alpine
 ---&gt; c0fc1c9c473b
Step 2/5 : WORKDIR /app
 ---&gt; Using cache
 ---&gt; f665e3b63c98
Step 3/5 : COPY project /app
 ---&gt; Using cache
 ---&gt; 8d4971fa2f3b
Step 4/5 : RUN npm install --production
 ---&gt; Using cache
 ---&gt; 9c21576cad06
Step 5/5 : CMD [&#34;node&#34;, &#34;src/index.js&#34;]
 ---&gt; Using cache
 ---&gt; 9783eef2c1d3
Successfully built 9783eef2c1d3
Successfully tagged dockerfile:latest
</code></pre><hr>
<p>A few lines of logs. As you can see this is <strong>Using cache</strong> text in multiple lines and the whole process took less than 1 sec. This is the power of layer caching. Nothing here was built from scratch, every layer comes from the cache.</p>
<p><strong>Important thing is,</strong> If any layer is created from scratch because of some changes in the source file, every next layer is built from scratch too.</p>
<p>The best practice here is to order docker file commands from least to most frequently change to take advantage of caching and this way we can optimize how fast the image gets built.</p>
<hr>
<h3 id="6-use-dockerignore-to-exclude-files-and-folder">6. Use .dockerignore to Exclude Files and Folder</h3>
<p>We should use the <code>.dockerignore</code> file to list all the files and folders that we want to exclude. we can create the <code>.dockerignore</code> file in the root directory and list all the files and folders we want to ignore.</p>
<p>When building the image, docker will look at the contents and ignore anything specified inside. Matching is done using <a href="https://go.dev/">Go</a>&rsquo;s <code>filepath.Match</code> rules.</p>
<p>A sample <code>.dockerignore</code> file would look like:</p>
<pre tabindex="0"><code class="language-shell:title=.dockerignore" data-lang="shell:title=.dockerignore"># ignore .git and .cache folders
.git
.cache

# ignore all markdown files
*.md

# ignore sensitive files
private.key
settings.json
</code></pre><hr>
<h3 id="7-make-use-of-multi-stage-builds">7. Make use of Multi-stage builds</h3>
<p>Let&rsquo;s assume that there are some contents in our project, that we need for building the image so during the build process but we don&rsquo;t need them in the final image itself to run the application.</p>
<p>For example in a Java-based application, we need JDK to compile the Java source code but JDK is not needed to run the Java application. In addition to that, we also use build tools like Maven or Gradle to build our Java application and those are also not needed in the final image.</p>
<p>Multi-stage builds allow us to use multiple temporary images during the build process but keep only the latest image as the final image. Let&rsquo;s see how it is done.</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile"># Build stage
FROM tomcat AS build

RUN apt-get update \
    &amp;&amp; apt-get -y install maven

WORKDIR /app

copy project /app

RUN mvn package

# Runtime stage
FROM tomcat

COPY --from=build /app/target/file.war /usr/local/tomcat/webapps

EXPOSE 8080

ENTRYPOINT [&#34;java&#34;, &#34;-jar&#34;, &#34;/usr/local/tomcat/webapps/file.war&#34;]
</code></pre><hr>
<p>Let&rsquo;s also look at the size comparison between two stages:</p>
<pre tabindex="0"><code class="language-shell:title=Console" data-lang="shell:title=Console">REPOSITORY                 TAG         IMAGE ID          SIZE
docker-single              latest      8d6b6a4d7fb6      259MB
docker-multi               latest      813c2fa9b114      156MB
</code></pre><hr>
<h3 id="8-use-the-least-privileged-user-or-non-root-user">8. Use the Least Privileged User or Non-Root User</h3>
<p>By default, Docker runs container processes as root inside of a container. However, this is a bad practice since a process running as root inside the container is running root in the docker host. Thus, if an attacker gains access to our container, they have access to all the root privileges and can perform several attacks on the Docker host, like:</p>
<ul>
<li>Copying sensitive info from the host&rsquo;s filesystem to the container.</li>
<li>Executing remote commands.</li>
</ul>
<p>To prevent this, we should run container processes with a non-root user or less privileged user.</p>
<pre tabindex="0"><code class="language-shell:title=Dockerfile" data-lang="shell:title=Dockerfile">...

# create group and user
RUN groupadd -r amar &amp;&amp; useradd -g amar amar

# set ownership and permissions
RUN chown -R amar:amar /app

# switch to user
USER amar

...
</code></pre><hr>
<blockquote>
<p>Some base images already have a generic user bundled in which we can use. For example, the node image already bundles a user called a <code>node</code>.</p>
</blockquote>
<hr>
<h3 id="9-scan-images-for-vulnerabilities">9. Scan Images for Vulnerabilities</h3>
<p>Once we build the image, we should scan the image for security vulnerabilities using the <code>docker scan</code> command. We need to be logged in to the Docker Hub to run the docker scan command to scan our images.</p>
<pre tabindex="0"><code class="language-shell:title=Console" data-lang="shell:title=Console">$ docker scan hello-world

Testing hello-world...

Organization:      docker-desktop-test
Package manager:   linux
Project name:      docker-image|hello-world
Docker image:      hello-world
Licenses:          enabled

✓ Tested 0 dependencies for known issues, no vulnerable paths found.

Note that we do not currently have vulnerability data for your image.
</code></pre><hr>
<p>In the background, Docker uses called <a href="https://snyk.io/">Snyk</a> to do the vulnerability scanning of the images. The scan uses a database of vulnerabilities that gets constantly updated so new ones get discovered and added all the time for different images.</p>
<hr>
<h3 id="summary">Summary</h3>
<ol>
<li>Use Official Docker Image as Base Image.</li>
<li>Use specific Image Version.
<ul>
<li>Do not use a random latest image tag</li>
<li>Fixate the version</li>
<li>The more specific, the better</li>
</ul>
</li>
<li>Use small sized Official Image.
<ul>
<li>Base image could not be based on full blown OS</li>
<li>Use image based on a leaner and smaller OS distribution like <a href="https://www.alpinelinux.org/">Alpine</a></li>
<li>Full blown operating system introduce more security vulnerabilities</li>
</ul>
</li>
<li>Minimize the Number of Layers.
<ul>
<li>RUN, COPY and ADD each create layers.</li>
<li>Each layer contain the difference from the previous layer.</li>
<li>Layers increase the size of the final image.</li>
</ul>
</li>
<li>Optimize Caching Image Layers.
<ul>
<li>Order dockerfile command from least to most frequently changing.</li>
</ul>
</li>
<li>Use .dockerignore to Exclude Files and Folder.
<ul>
<li>Use .dockerignore to explicitly exclude files and folders</li>
</ul>
</li>
<li>Make use of Multi-stage builds.
<ul>
<li>Multi-stage builds can decrease the size of our production images.</li>
<li>Small image size potentially means small attack surface.</li>
</ul>
</li>
<li>Use the Least Privileged User or Non-Root User</li>
<li>Scan Images for Vulnerabilities</li>
</ol>
<p>Follow all the above mentioned practices to make your Docker image leaner and more secure.</p>

</content>

<hr>
<p>
  Lastly, thank you for reading this post. For more awesome posts, you can also follow me on Twitter — <a href="https://twitter.com/iamarpandey">iamarpandey</a>, Github — <a href="https://github.com/amarlearning">amarlearning</a>.
</p>

<p>
  
  <a href="https://amarpandey.me/tags/docker/">#Docker</a>
  
  <a href="https://amarpandey.me/tags/best-practices/">#Best-Practices</a>
  
  <a href="https://amarpandey.me/tags/infrastructure/">#Infrastructure</a>
  
  <a href="https://amarpandey.me/tags/iac/">#Iac</a>
  
  <a href="https://amarpandey.me/tags/devops/">#Devops</a>
  
  <a href="https://amarpandey.me/tags/containers/">#Containers</a>
  
  <a href="https://amarpandey.me/tags/security/">#Security</a>
  
</p>

  </main>
  <footer><script>
    var currentYear = new Date().getFullYear();
    document.write("© " + currentYear + " by Amar Prakash Pandey. All rights reserved.");
</script></footer>

    
</body>

</html>
