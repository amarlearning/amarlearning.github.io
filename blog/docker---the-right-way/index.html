<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://amarpandey.me/favicon/favicon.png" />
<title>Docker - the right way | Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ</title>
<meta name="title" content="Docker - the right way" />
<meta name="description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles." />
<meta name="keywords" content="docker,best-practices,infrastructure,iac,devops,containers,security," />


<meta property="og:url" content="https://amarpandey.me/blog/docker---the-right-way/">
  <meta property="og:site_name" content="Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ">
  <meta property="og:title" content="Docker - the right way">
  <meta property="og:description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2022-01-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-01-23T00:00:00+00:00">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="Best-Practices">
    <meta property="article:tag" content="Infrastructure">
    <meta property="article:tag" content="Iac">
    <meta property="article:tag" content="Devops">
    <meta property="article:tag" content="Containers">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Docker - the right way">
  <meta name="twitter:description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">




  <meta itemprop="name" content="Docker - the right way">
  <meta itemprop="description" content="Docker - the right way - Best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.">
  <meta itemprop="datePublished" content="2022-01-23T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-01-23T00:00:00+00:00">
  <meta itemprop="wordCount" content="1769">
  <meta itemprop="keywords" content="Docker,Best-Practices,Infrastructure,Iac,Devops,Containers,Security">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header>


  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CN34V0ZGSQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-CN34V0ZGSQ');
  </script>


<a href="/" class="title">
  <h2>Amar Prakash Pandey - ᕦ(ò_óˇ)ᕤ</h2>
</a>
<nav><a href="/">Home</a>

<a href="/about/">About</a>

<a href="/projects/">Projects</a>


<a href="/blog">Blog</a>

</nav>

</header>
  <main>

<h1>Docker - the right way</h1>
<p>
  <i>
    <time datetime='2022-01-23' pubdate>
      23 Jan, 2022
    </time>
  </i>
</p>

<content>
  <p><img src="/images/docker-the-right-way/banner.png" alt="banner"></p>
<p>Docker is a software framework for building, running, and managing containers on servers and the cloud. Here are the several best practices for using Docker in production to improve security, optimize image size and write cleaner and more maintainable Dockerfiles.</p>
<hr>
<h3 id="1-use-official-docker-image-as-base-image">1. Use Official Docker Image as Base Image</h3>
<p>Always use the official or verified base image when writing the docker file. Let&rsquo;s say you are developing a java application and want to build it and run it as a docker image. Instead of taking a base operating system image and installing java, maven, and other tools you need for your application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM ubuntu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN apt-get update <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get install -y openjdk-8-jdk <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get install -y ant <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    apt-get clean;
</span></span></code></pre></div><hr>
<p>Use the official Java image for your application. This will not only make your docker file cleaner but also let you use an official and verified image which is already built using the best practices.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM openjdk
</span></span></code></pre></div><hr>
<h3 id="2-use-specific-image-version">2. Use specific Image Version</h3>
<p>As you see from the previous script we have chosen <code>OpenJDK</code> as our base image, but now when we build our application image from the above docker file, it will always use the <strong>latest</strong> tag of the <code>OpenJDK</code> image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Is same as FROM openjdk:latest</span>
</span></span><span style="display:flex;"><span>FROM openjdk
</span></span></code></pre></div><hr>
<p>The problem here is that we might get a different image version as in the previous build and the new image version may break stuff or cause unexpected behavior, so the <strong>latest</strong> tag is unpredictable, we don&rsquo;t know exactly which image we are getting. So instead of the random latest image tag, we need to fixate the version. <strong>We should be as specific as possible with the image version.</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM openjdk:11-alpine
</span></span></code></pre></div><hr>
<h3 id="3-use-small-sized-official-image">3. Use small sized Official Image</h3>
<p>There are multiple official images of <code>openjdk</code> not only with different version numbers but also with the different operating system distribution, so the question here is <strong>which one to choose?</strong> and <strong>does it even matter?</strong></p>
<p>If the image is based on a <strong>full-blown operating system distribution</strong> like ubuntu or centos which has a bunch of tools already packaged in, which makes the <strong>image size large</strong>. But most of the time, we don&rsquo;t need these tools in our application image.</p>
<p>In contrast, having smaller images means, we need less storage space in the image repository as well as on a deployment server and of course, we can transfer the images faster when pulling or pushing them from the repository.</p>
<p>In addition to the size, there is another issue with images on a full-blown operating system with lots of tools installed and that is a <strong>security issue</strong> because such a base usually contains hundreds of known vulnerabilities and basically creates a larger attack surface to your application image.</p>
<p>In comparison, using smaller images with leaner operating system distribution which bundle the necessary system tools and libraries, we are minimizing the attack surface and building more secure images.</p>
<hr>
<h3 id="4-minimize-the-number-of-layers">4. Minimize the Number of Layers</h3>
<p>Every line in our <code>Dockerfile</code> will be treated as an image layer. Each layer increases the size of images since they are cached. Therefore, as the number of layers increases, the size also increases. It&rsquo;s always a good idea to combine <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> commands as much as possible since they create layers.</p>
<p>You can test this out with the <code>docker history</code> command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker images
</span></span><span style="display:flex;"><span>REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
</span></span><span style="display:flex;"><span>dockerfile   latest    194f98552a02   <span style="color:#ae81ff">37</span> seconds ago   218MB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ docker history 194f98552a02
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IMAGE            CREATED BY                                       SIZE
</span></span><span style="display:flex;"><span>194f98552a02     COPY . . <span style="color:#75715e"># buildkit                              6.71kB</span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;        RUN /bin/sh -c pip install -r requirem..         35.5MB
</span></span><span style="display:flex;"><span>&lt;missing&gt;        COPY requirements.txt . <span style="color:#75715e"># buildkit               58B</span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;        WORKDIR /app
</span></span></code></pre></div><hr>
<p>If we see the above logs carefully, we can notice only the <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> command adds size to the image. we can reduce the image size by combining commands wherever possible. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>RUN apt-get update
</span></span><span style="display:flex;"><span>RUN apt-get install -y openjdk-8-jdk
</span></span></code></pre></div><hr>
<p>Can be combined into a single <code>RUN</code> command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>RUN apt-get update <span style="color:#f92672">&amp;&amp;</span> apt-get install -y openjdk-8-jdk
</span></span></code></pre></div><hr>
<p>Thus, creating a single layer instead of multiple, which reduces the size of the final image.</p>
<hr>
<h3 id="5-optimize-caching-image-layers">5. Optimize Caching Image Layers</h3>
<p>Docker images are built based on Dockerfile. In Dockerfile, each line generates its layer during the building process. The layers are also cached and reused between different building processes if no changes are detected.</p>
<p>Let&rsquo;s take a look at the dockerfile based on a node alpine image:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM node:17.0.1-alpine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>WORKDIR /app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>COPY project /app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN npm install --production
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;node&#34;</span>, <span style="color:#e6db74">&#34;src/index.js&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><hr>
<p>As we discussed before each line creates its cached layer. Let&rsquo;s build this docker image and see what is happening.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Step 1/5 : FROM node:17.0.1-alpine
</span></span><span style="display:flex;"><span>17.0.1-alpine: Pulling from library/node
</span></span><span style="display:flex;"><span>Digest: sha256:959c4fc79a753b8b797c4fc9da967c7a81b4a3a3ff93d484dfe00092bf9fd584
</span></span><span style="display:flex;"><span>Status: Downloaded newer image <span style="color:#66d9ef">for</span> node:17.0.1-alpine
</span></span><span style="display:flex;"><span> ---&gt; c0fc1c9c473b
</span></span><span style="display:flex;"><span>Step 2/5 : WORKDIR /app
</span></span><span style="display:flex;"><span> ---&gt; Using cache
</span></span><span style="display:flex;"><span> ---&gt; f665e3b63c98
</span></span><span style="display:flex;"><span>Step 3/5 : COPY project /app
</span></span><span style="display:flex;"><span> ---&gt; 8d4971fa2f3b
</span></span><span style="display:flex;"><span>Step 4/5 : RUN npm install --production
</span></span><span style="display:flex;"><span> ---&gt; Running in a5eac87912ce
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>up to date, audited <span style="color:#ae81ff">1</span> package in 371ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>found <span style="color:#ae81ff">0</span> vulnerabilities
</span></span><span style="display:flex;"><span>Removing intermediate container a5eac87912ce
</span></span><span style="display:flex;"><span> ---&gt; 9c21576cad06
</span></span><span style="display:flex;"><span>Step 5/5 : CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;node&#34;</span>, <span style="color:#e6db74">&#34;src/index.js&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> ---&gt; Running in 1ff9c5bb72e7
</span></span><span style="display:flex;"><span>Removing intermediate container 1ff9c5bb72e7
</span></span><span style="display:flex;"><span> ---&gt; 9783eef2c1d3
</span></span><span style="display:flex;"><span>Successfully built 9783eef2c1d3
</span></span><span style="display:flex;"><span>Successfully tagged dockerfile:latest
</span></span></code></pre></div><hr>
<p>Docker image from docker file was built completely from scratch, so it took 1 minute to build. Let&rsquo;s try to build again and see.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Step 1/5 : FROM node:17.0.1-alpine
</span></span><span style="display:flex;"><span> ---&gt; c0fc1c9c473b
</span></span><span style="display:flex;"><span>Step 2/5 : WORKDIR /app
</span></span><span style="display:flex;"><span> ---&gt; Using cache
</span></span><span style="display:flex;"><span> ---&gt; f665e3b63c98
</span></span><span style="display:flex;"><span>Step 3/5 : COPY project /app
</span></span><span style="display:flex;"><span> ---&gt; Using cache
</span></span><span style="display:flex;"><span> ---&gt; 8d4971fa2f3b
</span></span><span style="display:flex;"><span>Step 4/5 : RUN npm install --production
</span></span><span style="display:flex;"><span> ---&gt; Using cache
</span></span><span style="display:flex;"><span> ---&gt; 9c21576cad06
</span></span><span style="display:flex;"><span>Step 5/5 : CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;node&#34;</span>, <span style="color:#e6db74">&#34;src/index.js&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> ---&gt; Using cache
</span></span><span style="display:flex;"><span> ---&gt; 9783eef2c1d3
</span></span><span style="display:flex;"><span>Successfully built 9783eef2c1d3
</span></span><span style="display:flex;"><span>Successfully tagged dockerfile:latest
</span></span></code></pre></div><hr>
<p>A few lines of logs. As you can see this is <strong>Using cache</strong> text in multiple lines and the whole process took less than 1 sec. This is the power of layer caching. Nothing here was built from scratch, every layer comes from the cache.</p>
<p><strong>Important thing is,</strong> If any layer is created from scratch because of some changes in the source file, every next layer is built from scratch too.</p>
<p>The best practice here is to order docker file commands from least to most frequently change to take advantage of caching and this way we can optimize how fast the image gets built.</p>
<hr>
<h3 id="6-use-dockerignore-to-exclude-files-and-folder">6. Use .dockerignore to Exclude Files and Folder</h3>
<p>We should use the <code>.dockerignore</code> file to list all the files and folders that we want to exclude. we can create the <code>.dockerignore</code> file in the root directory and list all the files and folders we want to ignore.</p>
<p>When building the image, docker will look at the contents and ignore anything specified inside. Matching is done using <a href="https://go.dev/">Go</a>&rsquo;s <code>filepath.Match</code> rules.</p>
<p>A sample <code>.dockerignore</code> file would look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># ignore .git and .cache folders</span>
</span></span><span style="display:flex;"><span>.git
</span></span><span style="display:flex;"><span>.cache
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ignore all markdown files</span>
</span></span><span style="display:flex;"><span>*.md
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ignore sensitive files</span>
</span></span><span style="display:flex;"><span>private.key
</span></span><span style="display:flex;"><span>settings.json
</span></span></code></pre></div><hr>
<h3 id="7-make-use-of-multi-stage-builds">7. Make use of Multi-stage builds</h3>
<p>Let&rsquo;s assume that there are some contents in our project, that we need for building the image so during the build process but we don&rsquo;t need them in the final image itself to run the application.</p>
<p>For example in a Java-based application, we need JDK to compile the Java source code but JDK is not needed to run the Java application. In addition to that, we also use build tools like Maven or Gradle to build our Java application and those are also not needed in the final image.</p>
<p>Multi-stage builds allow us to use multiple temporary images during the build process but keep only the latest image as the final image. Let&rsquo;s see how it is done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Build stage</span>
</span></span><span style="display:flex;"><span>FROM tomcat AS build
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN apt-get update <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> apt-get -y install maven
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>WORKDIR /app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>copy project /app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN mvn package
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Runtime stage</span>
</span></span><span style="display:flex;"><span>FROM tomcat
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>COPY --from<span style="color:#f92672">=</span>build /app/target/file.war /usr/local/tomcat/webapps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXPOSE <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ENTRYPOINT <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;java&#34;</span>, <span style="color:#e6db74">&#34;-jar&#34;</span>, <span style="color:#e6db74">&#34;/usr/local/tomcat/webapps/file.war&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><hr>
<p>Let&rsquo;s also look at the size comparison between two stages:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>REPOSITORY                 TAG         IMAGE ID          SIZE
</span></span><span style="display:flex;"><span>docker-single              latest      8d6b6a4d7fb6      259MB
</span></span><span style="display:flex;"><span>docker-multi               latest      813c2fa9b114      156MB
</span></span></code></pre></div><hr>
<h3 id="8-use-the-least-privileged-user-or-non-root-user">8. Use the Least Privileged User or Non-Root User</h3>
<p>By default, Docker runs container processes as root inside of a container. However, this is a bad practice since a process running as root inside the container is running root in the docker host. Thus, if an attacker gains access to our container, they have access to all the root privileges and can perform several attacks on the Docker host, like:</p>
<ul>
<li>Copying sensitive info from the host&rsquo;s filesystem to the container.</li>
<li>Executing remote commands.</li>
</ul>
<p>To prevent this, we should run container processes with a non-root user or less privileged user.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create group and user</span>
</span></span><span style="display:flex;"><span>RUN groupadd -r amar <span style="color:#f92672">&amp;&amp;</span> useradd -g amar amar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># set ownership and permissions</span>
</span></span><span style="display:flex;"><span>RUN chown -R amar:amar /app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># switch to user</span>
</span></span><span style="display:flex;"><span>USER amar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><hr>
<blockquote>
<p>Some base images already have a generic user bundled in which we can use. For example, the node image already bundles a user called a <code>node</code>.</p>
</blockquote>
<hr>
<h3 id="9-scan-images-for-vulnerabilities">9. Scan Images for Vulnerabilities</h3>
<p>Once we build the image, we should scan the image for security vulnerabilities using the <code>docker scan</code> command. We need to be logged in to the Docker Hub to run the docker scan command to scan our images.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker scan hello-world
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Testing hello-world...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Organization:      docker-desktop-test
</span></span><span style="display:flex;"><span>Package manager:   linux
</span></span><span style="display:flex;"><span>Project name:      docker-image|hello-world
</span></span><span style="display:flex;"><span>Docker image:      hello-world
</span></span><span style="display:flex;"><span>Licenses:          enabled
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>✓ Tested <span style="color:#ae81ff">0</span> dependencies <span style="color:#66d9ef">for</span> known issues, no vulnerable paths found.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Note that we <span style="color:#66d9ef">do</span> not currently have vulnerability data <span style="color:#66d9ef">for</span> your image.
</span></span></code></pre></div><hr>
<p>In the background, Docker uses called <a href="https://snyk.io/">Snyk</a> to do the vulnerability scanning of the images. The scan uses a database of vulnerabilities that gets constantly updated so new ones get discovered and added all the time for different images.</p>
<hr>
<h3 id="summary">Summary</h3>
<ol>
<li>Use Official Docker Image as Base Image.</li>
<li>Use specific Image Version.
<ul>
<li>Do not use a random latest image tag</li>
<li>Fixate the version</li>
<li>The more specific, the better</li>
</ul>
</li>
<li>Use small sized Official Image.
<ul>
<li>Base image could not be based on full blown OS</li>
<li>Use image based on a leaner and smaller OS distribution like <a href="https://www.alpinelinux.org/">Alpine</a></li>
<li>Full blown operating system introduce more security vulnerabilities</li>
</ul>
</li>
<li>Minimize the Number of Layers.
<ul>
<li>RUN, COPY and ADD each create layers.</li>
<li>Each layer contain the difference from the previous layer.</li>
<li>Layers increase the size of the final image.</li>
</ul>
</li>
<li>Optimize Caching Image Layers.
<ul>
<li>Order dockerfile command from least to most frequently changing.</li>
</ul>
</li>
<li>Use .dockerignore to Exclude Files and Folder.
<ul>
<li>Use .dockerignore to explicitly exclude files and folders</li>
</ul>
</li>
<li>Make use of Multi-stage builds.
<ul>
<li>Multi-stage builds can decrease the size of our production images.</li>
<li>Small image size potentially means small attack surface.</li>
</ul>
</li>
<li>Use the Least Privileged User or Non-Root User</li>
<li>Scan Images for Vulnerabilities</li>
</ol>
<p>Follow all the above mentioned practices to make your Docker image leaner and more secure.</p>

</content>

<hr>
<p>
  Lastly, thank you for reading this post. For more awesome posts, you can also follow me on Medium<a href="https://medium.com/@amarlearning">amarlearning</a>, Github — <a href="https://github.com/amarlearning">amarlearning</a>.
</p>

<p>
  
  <a href="https://amarpandey.me/tags/docker/">#Docker</a>
  
  <a href="https://amarpandey.me/tags/best-practices/">#Best-Practices</a>
  
  <a href="https://amarpandey.me/tags/infrastructure/">#Infrastructure</a>
  
  <a href="https://amarpandey.me/tags/iac/">#Iac</a>
  
  <a href="https://amarpandey.me/tags/devops/">#Devops</a>
  
  <a href="https://amarpandey.me/tags/containers/">#Containers</a>
  
  <a href="https://amarpandey.me/tags/security/">#Security</a>
  
</p>

  </main>
  <footer><script>
    var currentYear = new Date().getFullYear();
    document.write("© " + currentYear + " by Amar Prakash Pandey. All rights reserved.");
</script></footer>

    
</body>

</html>
